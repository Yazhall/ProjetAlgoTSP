attendu du rapport
(i) modéliser proprement un graphe pondéré, 
(ii) implémenter plusieurs méthodes de résolution complémentaires (exactes, heuristiques et métaheuristiques), 
(iii) concevoir une expérimentation permettant de comparer rigoureusement des approches, 
(iv) pratiquer la mesure de performances (temps, mémoire, qualité), et (v) produire un rapport clair et argumenté.


 proposerez au moins deux représentations internes : 
 (i) matrice des distances D ∈ R^(n×n) 
 (ii) liste d’adjacence annotée (utile pour des graphes non complets)

validation :
Vérifiez que D est symétrique (cas métrique), que Dii = 0, et signalez les incohérences.


Possibilité de graphes non complets en masquant certaines arêtes.

Interface utilisateur et fonctionnalités:
Exigences minimales.
— Interface console (obligatoire) : menu clair pour 
    (i) générer/charger une instance, 
    (ii) choisir une méthode,
    (iii) lancer/afficher le résultat (coût, tour),
    (iv) sauvegarder la solution.
— Mode verbeux : traces textuelles optionnelles montrant les décisions (utile en débogage et pour l’oral).
— Visualisation (optionnelle mais recommandée) : tracé 2D du tour via matplotlib (euclidien) ou graphe via networkx.
— Paramètres : taille n, seed aléatoire, limite de temps/itérations, choix de la stratégie (glouton, 2-opt, etc.).

 Analyse de performance et protocole expérimental
 — Temps d’exécution (moyenne/écart-type sur k ≥ 5 répétitions, même seed par méthode si pertinent).
— Qualité : longueur du tour :, % d’écart relatif à la meilleure valeur obtenue parmi toutes vos méthodes.
— Taille de l’arbre exploré : nombre de nœuds (B&B), nb d’itérations (2-opt), etc.
— Mémoire (si mesurable facilement) : pic d’utilisation.

Facteurs d’étude:
— Taille n : au minimum n ∈ {10, 20, 30, 40} (plus si temps disponible).
— Type d’instance : euclidienne vs matrice arbitraire :, dense vs éparse.
— Paramètres heuristiques : critères d’arrêt, initialisation, ordre d’exploration.

Présentation des résultats:
— Tableaux comparatifs par n et par méthode (temps, qualité, etc.).
— Graphiques (temps en fonction de n :, qualité en fonction de n). Axes et unités clairement indiqués.
— Commentaires analytiques : expliquer pourquoi telle méthode se comporte mieux/pire selon les cas.

Taille adaptable et cas limites:
Exigences minimales.
— Supporter des tailles variables (au moins n ∈ [5, 60]). Pour les méthodes exactes, limiter
automatiquement n et prévenir l’utilisateur.
— Gérer les cas dégénérés (n=1, n=2, distances nulles, distances très grandes, graphes non
complets si vous en autorisez).

Conception, architecture et qualité logicielle
— Organisation du code : séparer clairement 
    (i) modèles (graphe/instances), 
    (ii) algorithmes,
    (iii) I/O et visualisation,
    (iv) scripts d’expériences.
— Lisibilité : noms explicites, commentaires pertinents, docstrings.
— Tests unitaires : au moins des tests pour les fonctions critiques (calcul de coût, validité d’un tour, opérations 2-opt, bornes B&B).
— Reproductibilité : fixer les seeds, sauvegarder les instances et résultats, fournir un README.