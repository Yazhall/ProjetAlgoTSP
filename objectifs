attendu du rapport
1. Les décisions de conception générales (structures de données, organisation du code, choix
d’algorithmes).
2. Les défis rencontrés et comment vous les avez surmontés (erreurs, cas limites, optimisation,
tests).
3. Une évaluation quantitative et qualitative de votre solution (temps d’exécution, qualité des
solutions, lisibilité, robustesse).
4. Un plan d’expérimentations reproductibles (tailles d’instances, métriques, protocole, paramètres, scripts)


 proposerez au moins deux représentations internes : 
 (i) matrice des distances D ∈ R^(n×n) 
 (ii) liste d’adjacence annotée (utile pour des graphes non complets)

validation :
Vérifiez que D est symétrique (cas métrique), que Dii = 0, et signalez les incohérences.


Interface utilisateur et fonctionnalités:
Exigences minimales.
— Interface console (obligatoire) : menu clair pour 
    (i) générer/charger une instance, 
    (ii) choisir une méthode,
    (iii) lancer/afficher le résultat (coût, tour),
    (iv) sauvegarder la solution.
— Mode verbeux : traces textuelles optionnelles montrant les décisions (utile en débogage et pour l’oral).
— Paramètres : taille n, seed aléatoire, limite de temps/itérations, choix de la stratégie (glouton, 2-opt, etc.).
— Visualisation (optionnelle mais recommandée) : tracé 2D du tour via matplotlib (euclidien) ou graphe via networkx.

 Analyse de performance et protocole expérimental
 — Temps d’exécution (moyenne/écart-type sur k ≥ 5 répétitions, même seed par méthode si pertinent).
— Qualité : longueur du tour :, % d’écart relatif à la meilleure valeur obtenue parmi toutes vos méthodes.
— Taille de l’arbre exploré : nombre de nœuds (B&B), nb d’itérations (2-opt), etc.
— Mémoire (si mesurable facilement) : pic d’utilisation.

Facteurs d’étude:
— Taille n : au minimum n ∈ {10, 20, 30, 40} (plus si temps disponible).
— Type d’instance : euclidienne vs matrice arbitraire :, dense vs éparse.
— Paramètres heuristiques : critères d’arrêt, initialisation, ordre d’exploration.

Présentation des résultats:
— Tableaux comparatifs par n et par méthode (temps, qualité, etc.).
— Graphiques (temps en fonction de n :, qualité en fonction de n). Axes et unités clairement indiqués.
— Commentaires analytiques : expliquer pourquoi telle méthode se comporte mieux/pire selon les cas.

Taille adaptable et cas limites:
Exigences minimales.
— Supporter des tailles variables (au moins n ∈ [5, 60]). Pour les méthodes exactes, limiter
automatiquement n et prévenir l’utilisateur.
— Gérer les cas dégénérés (n=1, n=2, distances nulles, distances très grandes, graphes non
complets si vous en autorisez).

Conception, architecture et qualité logicielle
— Organisation du code : séparer clairement 
    (i) modèles (graphe/instances), 
    (ii) algorithmes,
    (iii) I/O et visualisation,
    (iv) scripts d’expériences.
— Lisibilité : noms explicites, commentaires pertinents, docstrings.
— Tests unitaires : au moins des tests pour les fonctions critiques (calcul de coût, validité d’un tour, opérations 2-opt, bornes B&B).
— Reproductibilité : fixer les seeds, sauvegarder les instances et résultats, fournir un README.